#!/usr/bin/env python3
#
# Derived from https://github.com/unicode-rs/unicode-properties/blob/master/scripts/unicode.py
#
# Copyright 2011-2015 The Rust Project Developers. See <COPYRIGHT-RUST>
# or <https://github.com/rust-lang/rust/blob/master/COPYRIGHT>.
#
# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE> or
# <http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
# <LICENSE-MIT> or <http://opensource.org/licenses/MIT>, at your
# option. This file may not be copied, modified, or distributed
# except according to those terms.

# This script uses the following Unicode UCD data:
# - emoji/emoji-data.txt
#
# Since this should not require frequent updates, we just store this
# out-of-line and check the tables.rs file into git.

import fileinput, re, os, sys

preamble = '''// Based on https://github.com/unicode-rs/unicode-properties
//
// Copyright 2012-2015 The Rust Project Developers. See <COPYRIGHT-RUST>
// or <https://github.com/rust-lang/rust/blob/master/COPYRIGHT>.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE> or
// <http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT> or <http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// NOTE: The following code was generated by "scripts/unicode.py", do not edit directly

const RangeWithValue = @import("util.zig").RangeWithValue;
const EmojiStatus = @import("emoji.zig").EmojiStatus;
const GeneralCategory = @import("general_category.zig").GeneralCategory;
'''

UNICODE_VERSION = (15, 1, 0)

UNICODE_VERSION_NUMBER = "%s.%s.%s" %UNICODE_VERSION

# Download a UCD table file
def fetch_unidata(f):
    if not os.path.exists(os.path.basename(f)):
        os.system("curl -O https://www.unicode.org/Public/%s/ucd/%s"
                  % (UNICODE_VERSION_NUMBER, f))

    if not os.path.exists(os.path.basename(f)):
        sys.stderr.write("cannot load %s" % f)
        exit(1)

# Loads code point data from emoji-data.txt
# Implementation from unicode-segmentation
def load_emoji_properties(f):
    fetch_unidata(f)
    kinds = {}
    re1 = re.compile(r"^ *([0-9A-F]+) *; *(\w+)")
    re2 = re.compile(r"^ *([0-9A-F]+)\.\.([0-9A-F]+) *; *(\w+) *#")

    for line in fileinput.input(os.path.basename(f), openhook=fileinput.hook_encoded("utf-8")):
        kind = None
        d_lo = 0
        d_hi = 0
        m = re1.match(line)
        if m:
            d_lo = m.group(1)
            d_hi = m.group(1)
            kind = m.group(2).strip()
        else:
            m = re2.match(line)
            if m:
                d_lo = m.group(1)
                d_hi = m.group(2)
                kind = m.group(3).strip()
            else:
                continue
        d_lo = int(d_lo, 16)
        d_hi = int(d_hi, 16)
        if kind not in kinds:
            kinds[kind] = []
        kinds[kind].append((d_lo, d_hi))

    return kinds


def load_general_category_properties(f):
    fetch_unidata(f)
    general_category_list = []
    re1 = re.compile(r"^([0-9A-F]+);([^;]+);([A-Za-z]+);.*$")
    re2 = re.compile(r"^<(.*), First>$")
    re3 = re.compile(r"^<(.*), Last>$")
    re4 = re.compile(r"^<(.*)>$")

    special_group_lo = 0
    special_group_text = ''
    special_group_gc = ''
    for line in fileinput.input(os.path.basename(f), openhook=fileinput.hook_encoded("utf-8")):
        d_ch = 0
        d_name = ''
        d_gc = ''
        d_lo = 0
        d_hi = 0
        m = re1.match(line)
        if not m:
            continue

        d_ch = m.group(1)
        d_name = m.group(2).strip()
        d_gc = m.group(3).strip()

        if not d_name.startswith('<'):
            d_lo = int(d_ch, 16)
            d_hi = d_lo
            general_category_list.append((d_lo, d_hi, d_gc))
            continue
        m2 = re2.match(d_name)
        if m2:
            special_group_lo = int(d_ch, 16)
            special_group_text = m2.group(1)
            special_group_gc = d_gc
            continue
        m3 = re3.match(d_name)
        if m3:
            assert(special_group_text == m3.group(1))
            assert(special_group_gc == d_gc)
            d_lo = special_group_lo
            d_hi = int(d_ch, 16)
            general_category_list.append((d_lo, d_hi, d_gc))
            continue
        m4 = re4.match(d_name)
        if m4:
            d_lo = int(d_ch, 16)
            d_hi = d_lo
            general_category_list.append((d_lo, d_hi, d_gc))
            continue
        raise ValueError("unreachable")
    return general_category_list

def escape_char(c):
    if c == 'multi':
        return "\"<multiple code points>\""
    return "'\\u{%x}'" % c

def emit_table(f, name, t_data, t_type = "[]const struct { u21, u21 }", is_pub=True,
        pfun=lambda x: ".{ %s, %s }" % (escape_char(x[0]), escape_char(x[1]))):
    pub_string = "const"
    if is_pub:
        pub_string = "pub " + pub_string
    f.write("\n%s %s: %s = &.{\n" % (pub_string, name, t_type))
    for dat in t_data:
        f.write("    ")
        f.write(pfun(dat))
        f.write(",\n")
    f.write("};\n")

def emit_general_category_module(f):
    gc_variants = {
        "Lu": ".uppercase_letter",
        "Ll": ".lowercase_letter" ,
        "Lt": ".titlecase_letter" ,
        "Lm": ".modifier_letter" ,
        "Lo": ".other_letter",
        "Mn": ".nonspacing_mark",
        "Mc": ".spacing_mark" ,
        "Me": ".enclosing_mark",
        "Nd": ".decimal_number",
        "Nl": ".letter_number" ,
        "No": ".other_number",
        "Pc": ".connector_punctuation",
        "Pd": ".dash_punctuation" ,
        "Ps": ".open_punctuation" ,
        "Pe": ".close_punctuation" ,
        "Pi": ".initial_punctuation" ,
        "Pf": ".final_punctuation" ,
        "Po": ".other_punctuation",
        "Sm": ".math_symbol",
        "Sc": ".currency_symbol" ,
        "Sk": ".modifier_symbol" ,
        "So": ".other_symbol",
        "Zs": ".space_separator",
        "Zl": ".line_separator" ,
        "Zp": ".paragraph_separator",
        "Cc": ".control",
        "Cf": ".format" ,
        "Cs": ".surrogate" ,
        "Co": ".private_use" ,
        "Cn": ".unassigned",
    }

    general_category_char_table = load_general_category_properties("UnicodeData.txt")
    general_category_group_table = []
    for input_idx in range(len(general_category_char_table)):
        if general_category_char_table[input_idx][2] == "Cs":
            continue
        existing_group_count = len(general_category_group_table)
        if existing_group_count == 0:
            general_category_group_table.append(general_category_char_table[input_idx])
        elif (general_category_group_table[existing_group_count - 1][1] + 1 == general_category_char_table[input_idx][0] and
            general_category_group_table[existing_group_count - 1][2] == general_category_char_table[input_idx][2]):
            general_category_group_table[existing_group_count - 1] = (general_category_group_table[existing_group_count - 1][0],
                general_category_char_table[input_idx][1], general_category_group_table[existing_group_count - 1][2])
        else:
            general_category_group_table.append(general_category_char_table[input_idx])
    emit_table(f, "general_category", general_category_group_table, "[]const RangeWithValue(GeneralCategory)",
            pfun=lambda x: ".{ %s, %s, %s }" % (escape_char(x[0]), escape_char(x[1]), gc_variants[x[2]]))


def emit_emoji_module(f):
    emoji_status_table = load_emoji_properties("emoji/emoji-data.txt")
    # we combine things together here.
    
    # `Extended_Pictographic`` is only for future proof usages, we ignore it here.
    # emoji_prop_list = ["Emoji", "Emoji_Presentation", "Emoji_Modifier", "Emoji_Modifier_Base", "Emoji_Component", "Extended_Pictographic"]
    emoji_prop_list = ["Emoji", "Emoji_Presentation", "Emoji_Modifier", "Emoji_Modifier_Base", "Emoji_Component"]

    # need to skip surrogates because they're not representable by rust `char`s
    emoji_status_table["Surrogate"] = [(0xD800, 0xDFFF)]
    emoji_prop_list.append("Surrogate")
    
    emoji_prop_list_len = [len(emoji_status_table[x]) for x in emoji_prop_list]
    emoji_prop_count = len(emoji_prop_list)
    code_point_first = 0
    code_point_last = 0x10FFFF
    emoji_prop_list_pos = [0 for _ in emoji_prop_list]
    cur_group_first = code_point_first
    emoji_table = []
    def group_text(s):
        if s == "Surrogate":
            return "<Surrogate>"
        elif s == "":
            return ".non_emoji"
        elif s == "Emoji_Component":
            return ".non_emoji_but_emoji_component"
        elif s == "Emoji;Emoji_Presentation":
            return ".emoji_presentation"
        elif s == "Emoji;Emoji_Presentation;Emoji_Modifier_Base":
            return ".emoji_presentation_and_modifier_base"
        elif s == "Emoji;Emoji_Modifier_Base":
            return ".emoji_modifier_base"
        elif s == "Emoji":
            return ".emoji_other"
        elif s == "Emoji;Emoji_Presentation;Emoji_Component":
            return ".emoji_presentation_and_emoji_component"
        elif s == "Emoji;Emoji_Presentation;Emoji_Modifier;Emoji_Component":
            return ".emoji_presentation_and_modifier_and_emoji_component"
        elif s == "Emoji;Emoji_Component":
            return ".emoji_other_and_emoji_component"
        else:
            return ".{ .new_combination = \"" + s + "\" }"
    while cur_group_first <= code_point_last:
        cur_group_props = []
        cur_group_last = code_point_last
        for prop_list_idx in range(emoji_prop_count):
            if emoji_prop_list_pos[prop_list_idx] >= emoji_prop_list_len[prop_list_idx]:
                continue
            elif emoji_status_table[emoji_prop_list[prop_list_idx]][emoji_prop_list_pos[prop_list_idx]][0] > cur_group_first:
                cur_group_last = min(cur_group_last, emoji_status_table[emoji_prop_list[prop_list_idx]][emoji_prop_list_pos[prop_list_idx]][0] - 1)
            else:
                cur_group_props.append(emoji_prop_list[prop_list_idx])
                cur_group_last = min(cur_group_last, emoji_status_table[emoji_prop_list[prop_list_idx]][emoji_prop_list_pos[prop_list_idx]][1])
        cur_group_text = group_text(";".join(cur_group_props))
        if cur_group_text != "<Surrogate>":
            emoji_table.append((cur_group_first, cur_group_last, cur_group_text))
        for prop_list_idx in range(emoji_prop_count):
            if emoji_prop_list_pos[prop_list_idx] >= emoji_prop_list_len[prop_list_idx]:
                continue
            elif emoji_status_table[emoji_prop_list[prop_list_idx]][emoji_prop_list_pos[prop_list_idx]][0] > cur_group_first:
                continue
            else:
                if cur_group_last == emoji_status_table[emoji_prop_list[prop_list_idx]][emoji_prop_list_pos[prop_list_idx]][1]:
                    emoji_prop_list_pos[prop_list_idx] += 1
        cur_group_first = cur_group_last + 1

    emit_table(f, "emoji_status", emoji_table, "[]const RangeWithValue(EmojiStatus)",
            pfun=lambda x: ".{ %s, %s, %s }" % (escape_char(x[0]), escape_char(x[1]), x[2]))

if __name__ == "__main__":
    r = "tables.zig"
    if os.path.exists(r):
        os.remove(r)
    with open(r, "w") as rf:
        # write the file's preamble
        rf.write(preamble)

        rf.write("""
/// The version of [Unicode](http://www.unicode.org/)
/// that this version of unicode-properties is based on.
pub const unicode_version: struct { u64, u64, u64 } = .{ %s, %s, %s };
""" % UNICODE_VERSION)

        ### general category module
        emit_general_category_module(rf)
        ### emoji module
        emit_emoji_module(rf)
